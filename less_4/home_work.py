"""
# Написать свой cache декоратор c максимальным размером кеша и его очисткой при необходимости.
# Декоратор должен перехватывать аргументы оборачиваемой функции
# Декоратор должен иметь хранилище, где будут сохраняться все перехваченные аргументы и результаты выполнения
декорируемой функции
# Декоратор должен проверять наличие перехваченных аргументов в хранилище. Если декорируемая функция уже вызывалась
 с такими аргументами, она не будет вызываться снова, вместо этого декоратор вернет сохраненное значение.
# Декоратор должен принимать один аргумент - максимальный размер хранилища.
# Если хранилище заполнено, нужно удалить 1 любой элемент, чтобы освободить место под новый.
"""

safe = {}


def do_cache(maxsize):
    def cache(func):
        def wrapped(*args):
            arguments = f'{args[0]}**{args[1]}'
            if arguments in safe:
                return safe[arguments]
            rez = func(*args)
            if len(safe) == maxsize:
                safe.popitem()
            safe[arguments] = rez
            return safe[arguments]
        return wrapped
    return cache


@do_cache(maxsize=3)
def get_value(a, b):
    return a ** b


while True:
    x = int(input("Укажите число, для выхода введите 0 "))
    if not x:
        break
    y = int(input("Укажите степень числа "))

    print(f'Результат возведения в степень: {get_value(x, y)}')



